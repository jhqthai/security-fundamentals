#include <stdio.h>
#include "openssl/evp.h"
#include <string.h>
#include <stdbool.h>

#define MAX_LENGTH 16 // A global variable t define max-length

int main (int argc, const char *argv[])
{
  bool match;
	/* This variable is used to store the ciphertext provided to you. Make sure to use the proper format, eg. the hex 'd23a' would be written as {0xd2,0x3a} in C */
	// 2075386b75eed8b4f2b4a9c9b76967d072fe22daca7b8f5a56d16ce6ee483b59
	unsigned char ciphertxt[] = {0x20, 0x75, 0x38, 0x6b, 0x75, 0xee, 0xd8, 0xb4, 0xf2, 0xb4, 0xa9, 0xc9, 0xb7, 0x69, 0x67, 0xd0, 0x72, 0xfe, 0x22, 0xda, 0xca, 0x7b, 0x8f, 0x5a, 0x56, 0xd1, 0x6c, 0xe6, 0xee, 0x48, 0x3b, 0x59};
	

	// This is the plaintext that we are encrypting. Do not change it as it may result in a different ciphertext
	char plaintext[]= "This is a top secret.";
	
	// Pointer fp used to point to the English words file provided along.
	FILE *fp;
	
	// The initialization Vector is set to 0
	// Use when envrypting the file, to avoid the same output when have 2 different file with the same key?
	unsigned char iv[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	
	// Output buffer set to 1024 size
	unsigned char outbuf [1024];
	
	// Some other variables that are used in the program
	int outlen = 0, tmplen = 0;
	
	EVP_CIPHER_CTX ctx; // Initialise varaible ctx?
	
	/* Use this statement to check is the words.txt file can be opened in 'rt' permission */
	if ((fp = fopen("words.txt", "rt")) == NULL)
	{
		/* Print a statement if the above condition is not met */
		printf("Error! Cannot read text file");
		return 0;
	}
	
	char key [MAX_LENGTH]; //define array to store the key getting from the dictionary
	
	while (fgets(key, MAX_LENGTH, fp) != NULL)
	{
		for(int i = 0; i < MAX_LENGTH; i++)
		{
			if (key[i] == '\n' || key[i] == 0 ) //when key is less than 16 characters, get the left part with “ “ ;
			{
				for (int j = i; j < strlen(key); j++)
				{
					key[j] = ' ';
				}
				break;
			}
		}
		
		
		// Use the EVP library to initialize cipher
		EVP_CIPHER_CTX_init (&ctx);
		
		// Use the EVP library to encrypt the cipher
		EVP_EncryptInit_ex (&ctx, EVP_aes_128_cbc(), NULL, key, iv);
		
		
		// Checking to see if EVP_EncryptUpdate is valid or not
		if (!EVP_EncryptUpdate (&ctx, outbuf, &outlen, plaintext, strlen(plaintext)))
		{	
			/*Error */
			printf("EVP_EncryptUpdate invalid!");
			return 0;
		}
		
		// Buffer passed to EVP_EncryptFinal() must be after data just encrypted to avoid overwriting it.
				
		// Checking to see if !EVP_EncryptFinal_ex is valid or not
		if (!EVP_EncryptFinal_ex (&ctx, outbuf + outlen, &tmplen))
		{
			/*Error*/
			printf("EVP_EncryptFinal_ex invalid!");
			return 0;
		}
				
		outlen += tmplen;
		
		EVP_CIPHER_CTX_cleanup (&ctx);
			
		//print curret key and its corresponding ciphertext
		printf ("The key is : %s       The Corresponding Cipher Text Is:  ", key); 
		for(int j = 0; j < outlen; j++) // Use a loop to print out the buffer
  	{
			printf ("%x", outbuf[j]);
		}
		printf ("\n");
		
		int counter = 0;
		for(int q = 0; q < outlen; q++)
		{
			/* Judge whether the cipher text generated by this key is match for the provoded one */
  		/* As the whole ciphertext cannot be matched at once, use this loop to match it bit by bit */
			// TODO: Match the whole thing instead of just 1 bit lol you retard
			
			// If match, continue, till null
			// If matched, and end of array, breakout			
//			if (counter == outlen && match == true)
//			  break;
			if(ciphertxt[q] != outbuf[q])
			{
		    match = false;
		    counter = 1;
      }
		  else
		  {
		    // Reset counter when there are no match
		    // Break out of current key when does not match
		    match = true;
		    counter ++;
        break;
      } 
		}
		
		/* If the generated ciphertext matched with the one provided*/			
		if (match)
		{
			printf ("\n*****************************************************\n");
			printf(" The key is: %s\n", key);
			printf("\nThe Cypher text using the above key is: \n");
			
			/* Print the text in the buffer */
			for(int i = 0; i < outlen; i++)
			{
			  printf("%x", outbuf[i]);
			}
			printf ("\n");
			printf ("The Cipher text we were serching for is: \n");
						
			/* Print the provided ciphertext*/
			for(int i = 0; i < outlen; i++)
			{
			  printf("%x", ciphertxt[i]);
			}
			printf ("\n");
			
			/* Print the length of the ciphertext */
			// TODO: Fix this up properly later
			printf("\nThe Cipher length is: %lu \n", sizeof(ciphertxt));
			
			printf ("\n*****************************************************\n");
			return 0;
		}
		if (!match)
		{
      printf ("\n*****************************************************\n");
      printf("GETFKED");
      printf ("\n*****************************************************\n");
      return 0;
		}  
	}
	fclose (fp);
	return 0;
}
